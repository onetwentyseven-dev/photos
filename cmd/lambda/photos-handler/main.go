package main

import (
	"context"
	"encoding/gob"
	"fmt"
	"net/url"
	"os"
	"os/signal"
	"photos"
	"photos/internal/server"
	"photos/internal/store/mysql"
	"syscall"
	"time"

	"github.com/akrylysov/algnhsa"
	awsConfig "github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/golang-migrate/migrate/v4"
	mysqlMigrateDriver "github.com/golang-migrate/migrate/v4/database/mysql"
	"github.com/srinathgs/mysqlstore"

	"github.com/ddouglas/authenticator"
	"github.com/sirupsen/logrus"
)

var (
	logger = logrus.New()
)

func main() {
	gob.Register(make(map[string]any))

	ctx := context.TODO()

	awsCfg, err := awsConfig.LoadDefaultConfig(ctx)
	if err != nil {
		logger.WithError(err).Fatal("failed to load aws default config")
	}

	loadConfig(ctx, awsCfg)

	dbx, db, err := initDB()
	if err != nil {
		logger.WithError(err).Error("failed to initialize database")
	}

	s3Client := s3.NewFromConfig(awsCfg)

	if appConfig.RunMigrations {
		migrateDriver, err := mysqlMigrateDriver.WithInstance(db, &mysqlMigrateDriver.Config{
			MigrationsTable:  "migrations",
			DatabaseName:     appConfig.DB.Name,
			StatementTimeout: time.Second * 5,
		})
		if err != nil {
			logger.WithError(err).Fatal("failed to initialize migration driver")
		}

		migrateSource, err := photos.MigrationFS()
		if err != nil {
			logger.WithError(err).Fatal("failed to initialize migration source")
		}

		m, err := migrate.NewWithInstance("iofs", migrateSource, "mysql", migrateDriver)
		if err != nil {
			logger.WithError(err).Fatal("failed to initialize migration instance")
		}

		err = m.Up()
		if err != nil && err != migrate.ErrNoChange {
			logger.WithError(err).Fatal("failed to run migrations")
		}
	}

	appURL, err := url.Parse(appConfig.AppURL)
	if err != nil {
		logger.WithError(err).Fatal("failed to parse app url")
	}

	mysqlSessionStore, err := mysqlstore.NewMySQLStoreFromConnection(db, "sessions", "/", 3600, []byte(appConfig.Session.Key))
	if err != nil {
		logger.WithError(err).Fatal("failed to initialize mysql session store")
	}

	mysqlSessionStore.Options.Domain = appURL.Hostname()

	imageRepository := mysql.NewImageRepository(dbx)
	userRepository := mysql.NewUserRepository(dbx)

	authenticator, err := authenticator.New(&authenticator.Config{
		ClientID:     appConfig.Auth0.ClientID,
		ClientSecret: appConfig.Auth0.ClientSecret,
		Tenant:       appConfig.Auth0.Domain,
		CallbackURL:  fmt.Sprintf("%s%s", appConfig.AppURL, appConfig.Auth0.CallbackPath),
	})
	if err != nil {
		logger.WithError(err).Fatal("failed to provision authenticator service")
	}

	server := server.New(
		appConfig.AppURL,
		appConfig.Environment,
		appConfig.Server.Port,
		logger,

		authenticator,
		s3Client,
		mysqlSessionStore,

		userRepository,
		imageRepository,
	)

	if appConfig.Mode == "lambda" {
		algnhsa.ListenAndServe(server.Mux(), &algnhsa.Options{
			// RequestType: algnhsa.RequestTypeAPIGatewayV2,
			// DebugLog: true,
			// UseProxyPath: true,
			BinaryContentTypes: []string{
				"image/jpeg",
			},
		})
		return
	}

	// Channel to listen for errors generated by api server
	serverErrors := make(chan error, 1)

	// Channel to listen for interrupts and to run a graceful shutdown
	osSignals := make(chan os.Signal, 1)
	signal.Notify(osSignals, os.Interrupt, syscall.SIGTERM)

	// Start up our server
	go func() {
		serverErrors <- server.Start()
	}()

	// Blocking until read from channel(s)
	select {
	case err := <-serverErrors:
		logger.Fatalf("error starting server: %v", err.Error())

	case <-osSignals:
		logger.Println("starting server shutdown...")
		ctx, cancel := context.WithTimeout(context.Background(), time.Second)
		defer cancel()

		err := server.GracefullyShutdown(ctx)
		if err != nil {
			logger.Fatalf("error trying to shutdown http server: %v", err.Error())
		}

		os.Exit(0)

	}

}
